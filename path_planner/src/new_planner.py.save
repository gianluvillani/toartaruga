#!/usr/bin/env python

import tf
import tf2_ros
import rospy
import operator
import math
import numpy as np
import geometry_msgs.msg
import matplotlib.pyplot as plt
from std_msgs.msg import Float32
from nav_msgs.msg import Path, Odometry
from geometry_msgs.msg import PoseStamped
from tf.transformations import euler_from_quaternion
from low_level_interface.msg import lli_ctrl_request
#TODO: Use low_level_interface on NVIDIA
from geometry_msgs.msg import Twist
from spline_interpolation import Spline2D
from obstacle_detector.msg import Obstacles
import copy
import random
import path_utils
import matplotlib.pyplot as plt
import timeit
import path_utils
#import plot_utils
from spline_interpolation import Spline2D
DEBUG = False


def log(s):
    if DEBUG:
        print(s)



def get_course():
    t = np.arange(0, math.pi * 2, 0.01)
    x = np.cos(t)
    y = np.sin(t)
    return path_utils.Path(list(x), list(y))


class DynamicPlanner:
    def __init__(self, safety_distance=0.1):
        self.state_car = PoseStamped()
        self.obstacle_msg = Obstacles()
        self.x_car = 0
        self.y_car = 0
        self.yaw_car = 0
        self.car_index = 0
        self. min_dist_back_on_path = 0.5

        self.safety_distance = safety_distance
        self.circle_obstacles = []

        self.reference_path = get_course()
        self.previous_path = copy.deepcopy(self.reference_path)

        self.path_available = False
        self.state_available = False
        self.obstacles_available = False
        self.reset_obstacles = True

        self.min_dist_obstacle_crossing = 0.9
        self.ang_on_path = math.pi / 5

        # Access rosparams
        #self.obstacles_top = rospy.get_param(rospy.get_name() + '/obstacles_topic')
        #self.car_pose_top = rospy.get_param(rospy.get_name() + "/car_pose_topic")
        #self.path_top = rospy.get_param(rospy.get_name() + "/path_topic")
        #self.replanner_path_top = rospy.get_param(rospy.get_name() + "/replanner_path_topic")

        # Publishers/Subscriber
        self.sub_obstacles = rospy.Subscriber('/obstacles', Obstacles, self.save_obstacles)
        #self.sub_car_pose = rospy.Subscriber(self.car_pose_top, PoseStamped, self.save_state)
        #self.sub_path = rospy.Subscriber(self.path_top, Path, self.save_path)
        self.pub_path = rospy.Publisher('/sample_path', Path)
        #self.pub_marker = rospy.Publisher('/marker', PoseStamped)

    def save_path(self, path_msg):
        self.reference_path = path_msg
        self.path_available = True

    def save_state(self, state_msg):
        self.state_car = state_msg
        self.state_available = True

    def save_obstacles(self, obstacle_msg):
        self.obstacle_msg = obstacle_msg
        self.obstacles_available = True

    def transform2global(self, x, y):
        alpha = math.atan2(y, x)
        theta = math.pi + self.yaw_car
        rho = math.sqrt(x ** 2 + y ** 2)
        x_global = self.x_car + rho * math.cos(alpha + theta)
        y_global = self.y_car + rho * math.sin(alpha + theta)
        #return x_global, y_global
        return x, y

    def on_path(self, obstacle):
        obstacle_on_path = False
        for x, y in zip(self.previous_path.cx, self.previous_path.cy):
            if math.sqrt((x - obstacle.x) ** 2 + (y - obstacle.y) ** 2) < \
                    obstacle.r + self.safety_distance:
                obstacle_on_path = True
                break
        return obstacle_on_path

    def parse_obstacles(self, obstacle_msg):
        if self.reset_obstacles:
            self.circle_obstacles = []
        car_index = self.reference_path.get_closest_index_on_path(self.x_car, self.y_car)
        self.car_index = car_index
        for circle in obstacle_msg:#.circles:
            #x_obstacle_global, y_obstacle_global = self.transform2global(circle.center.x, circle.center.y)
            x_obstacle_global = circle.x
            y_obstacle_global = circle.y
            obstacle = path_utils.Obstacle(x_obstacle_global, y_obstacle_global, circle.radius)

            index_on_path = self.reference_path.get_closest_index_on_path(obstacle.x, obstacle.y)
            gradient_on_path = self.reference_path.compute_direction(index_on_path)

            # Compute n waypoints on the circle
            obstacle.compute_wp(gradient_on_path, self.safety_distance)
            obstacle.index_on_path = (index_on_path - car_index) % self.reference_path.get_length()
            if len(self.circle_obstacles) == 0:
                self.circle_obstacles.append(obstacle)
            else:
                for index, sorted_obstacle in enumerate(self.circle_obstacles):
                    if obstacle.index_on_path <= sorted_obstacle.index_on_path:
                        self.circle_obstacles.insert(index, obstacle)
                        break
                if obstacle.index_on_path > self.circle_obstacles[-1].index_on_path:
                    self.circle_obstacles.append(obstacle)

    def crossing(self, wp1, wp2):
        delta_x = wp1.obstacle.x - wp2.obstacle.x
        delta_y = wp1.obstacle.y - wp2.obstacle.y
        if delta_x != 0:
            m = delta_y / delta_x
            q = wp1.obstacle.y - m * wp1.obstacle.x
            if (wp1.y >= m * wp1.x + q) and (wp2.y >= m * wp2.x + q):
                return False
            if (wp1.y <= m * wp1.x + q) and (wp2.y <= m * wp2.x + q):
                return False
            return True
        else:
            if (wp1.x - wp1.obstacle.x) * (wp2.x - wp2.obstacle.x) >= 0:
                return False
        return True

    def check_feasible_path(self, current_wp, next_wp):
        if next_wp.obstacle is None:
            return True
        distance_obstacle = math.hypot(current_wp.obstacle.x - next_wp.obstacle.x,
                                       current_wp.obstacle.y - next_wp.obstacle.y)
        clean_distance = distance_obstacle - (current_wp.obstacle.r + next_wp.obstacle.r)
        if self.crossing(current_wp, next_wp) and clean_distance < self.min_dist_obstacle_crossing:
            return False
        else:
            return True

    def backward_recursion(self):
        fake_first_obstacle = path_utils.Obstacle(x=self.circle_obstacles[0].x,
                                                  y=self.circle_obstacles[0].y,
                                                  r=self.circle_obstacles[0].r)
        index_on_path = self.previous_path.get_closest_index_on_path(fake_first_obstacle.x, fake_first_obstacle.y)
        fake_first_obstacle.index_on_path = (index_on_path - self.car_index) % self.previous_path.get_length()
        fake_first_obstacle.waypoints = [path_utils.WayPoint(self.circle_obstacles[0].waypoints[0].x,
                                                             self.circle_obstacles[0].waypoints[0].y,
                                                             None)]
        self.circle_obstacles.append(fake_first_obstacle)
        for wp in self.circle_obstacles[-1].waypoints:
            wp.end = True
            wp.feasible = True
            wp.set_cost_to_go(0)

        for i in range(len(self.circle_obstacles)-2, -1, -1):
            current_obs = self.circle_obstacles[i]
            next_obs = self.circle_obstacles[i+1]
            next_wps = next_obs.waypoints
            log('CURRENT OBSTACLE: ' + str(current_obs.x) + ", " + str(current_obs.y))
            # TODO: If clear distance is enough: indexes on path / ds
            distance_on_path = ((next_obs.index_on_path - current_obs.index_on_path) % self.previous_path.get_length()) * self.previous_path.ds
            dist_last = (next_obs.r + next_obs.num_wp * self.safety_distance) / math.cos(self.ang_on_path)
            dist_first = (current_obs.r + current_obs.num_wp * self.safety_distance) / math.cos(self.ang_on_path)
            clean_distance = distance_on_path - (dist_last + dist_first)
            if clean_distance > self.min_dist_back_on_path:
                next_wps = []
                additional_wp = int(clean_distance / (self.previous_path.ds * 2))
                shift_index = int((clean_distance/additional_wp / self.previous_path.ds))
                bias_index = int(dist_last/self.previous_path.ds)
                old_wp_list = next_obs.waypoints
                for i in range(additional_wp):
                    current_wp_index = (next_obs.index_on_path - (shift_index * (i+1) + bias_index) + self.car_index) % self.previous_path.get_length()
                    new_wp = path_utils.WayPoint(self.previous_path.cx[current_wp_index], self.previous_path.cy[current_wp_index], None)
                    new_wp.feasible = True
                    self.find_optimal_next(new_wp, old_wp_list)
                    # new_wp.next_wp = old_wp
                    old_wp_list = [new_wp]
                next_wps = [new_wp]

            for wp0 in current_obs.waypoints:
                log('Current waypoint: ' + str(wp0.x) + ", " + str(wp0.y))
                if wp0.obstacle is not None:
                    log('   On obstacle: ' + str(wp0.obstacle.x) + ", " + str(wp0.obstacle.y))
                feasible_waypoints = []
                for wp1 in next_wps:
                    if wp1.feasible:
                        if self.check_feasible_path(wp0, wp1):
                            feasible_waypoints.append(wp1)
                if len(feasible_waypoints) == 0:
                    wp0.feasible = False
                else:
                    wp0.feasible = True
                    self.find_optimal_next(current_wp=wp0, next_feasible_wps=feasible_waypoints)

    def find_optimal_next(self, current_wp, next_feasible_wps):
        index_on_path = self.previous_path.get_closest_index_on_path(current_wp.x, current_wp.y)
        reward_now = math.hypot(current_wp.x - self.previous_path.cx[index_on_path],
                                current_wp.y - self.previous_path.cy[index_on_path])
        best_wp = next_feasible_wps[0]
        min_cost = 100

        for w in next_feasible_wps:
            log('       Possible future waypoint: ' + str(current_wp.x) + ", " + str(current_wp.y))
            if w.obstacle is not None:
                log('       On obstacle: ' + str(w.obstacle.x) + ", " + str(w.obstacle.y))
                log('       Future cost:' + str(w.get_cost_to_go()))
            if w.get_cost_to_go() < min_cost:
                min_cost = w.get_cost_to_go()
                best_wp = w
        log('           Best future cost: ' + str(min_cost))
        log('           With point: ' + str(best_wp.x) + ", " + str(best_wp.y))
        current_wp.set_cost_to_go(min_cost + reward_now)
        current_wp.next_wp = best_wp
        return best_wp


class FakeObstacle:
    def __init__(self, x, y, r):
        self.x = x
        self.y = y
        self.radius = r


if __name__ == "__main__":
    planner = DynamicPlanner(safety_distance=0.1)
    planner.x_car = 1
    planner.y_car = 0
    planner.yaw_car = math.pi/2
    circle_1 = FakeObstacle(0, 1.2, 0.1)
    circle_2 = FakeObstacle(1, 0, 0.1)
    circle_3 = FakeObstacle(-0.8, 0, 0.2)
    circle_4 = FakeObstacle(0, -1.2, 0.1)
    circle_5 = FakeObstacle(1, 0, 0.3)
    circle_6 = FakeObstacle(0.7, 0.7, 0.1)
    circle_7 = FakeObstacle(-0.7, -0.7, 0.1)
    obstacle_msg = [circle_1, circle_2]#, circle_3, circle_4, circle_5]
    start = timeit.timeit()
    planner.parse_obstacles(obstacle_msg)
    planner.backward_recursion()
    end = timeit.timeit()

    min_cost = 100
    start_wp = planner.circle_obstacles[0].waypoints[0]
    for wp in planner.circle_obstacles[0].waypoints:
        if wp.get_cost_to_go() < min_cost:
            min_cost = wp.get_cost_to_go()
            start_wp = wp
    print(start_wp.x)
    print(start_wp.y)

    next_wp = start_wp
    to_be_splined_x = [start_wp.x]
    to_be_splined_y = [start_wp.y]
    end = False
    while not end:
        to_be_splined_x.append(next_wp.x)
        to_be_splined_y.append(next_wp.y)
        end = next_wp.end
        if not next_wp.end:
            next_wp = next_wp.next_wp
    spl = Spline2D(to_be_splined_x[1:], to_be_splined_y[1:])
    s = np.arange(0, spl.s[-1], 0.1)
    sx = []
    sy = []
    for i_s in s:
        ix, iy = spl.calc_position(i_s)
        sx.append(ix)
        sy.append(iy)
    plt.plot(sx, sy)
    plt.xlim([-2, 2])
    plt.ylim([-2, 2])
    plt.show()

    #plot_utils.planner_plot(planner)







#!/usr/bin/env python

#import tf
#import tf2_ros
import rospy
#import operator
import math
import numpy as np
#import geometry_msgs.msg
#import matplotlib.pyplot as plt
#from std_msgs.msg import Float32
#from nav_msgs.msg import Path, Odometry
#from geometry_msgs.msg import PoseStamped
#from tf.transformations import euler_from_quaternion
#from low_level_interface.msg import lli_ctrl_request
#TODO: Use low_level_interface on NVIDIA
#from geometry_msgs.msg import Twist
#from spline_interpolation import Spline2D
#from obstacle_detector.msg import Obstacles
import copy
import random
import path_utils
import matplotlib.pyplot as plt
import timeit
import path_utils
import plot_utils
from pycubicspline import Spline2D
DEBUG = False


def log(s):
    if DEBUG:
        print(s)



def get_course():
    t = np.arange(0, math.pi * 2, 0.01)
    x = np.cos(t)
    y = np.sin(t)
    return path_utils.Path(list(x), list(y))


class DynamicPlanner:
    def __init__(self, safety_distance=0.1):
        #self.state_car = PoseStamped()
        #self.obstacle_msg = Obstacles()
        self.x_car = 0
        self.y_car = 0
        self.yaw_car = 0
        self.car_index = 0
        self. min_dist_back_on_path = 0.5

        self.safety_distance = safety_distance
        self.circle_obstacles = []

        self.reference_path = get_course()
        self.previous_path = copy.deepcopy(self.reference_path)

        self.path_available = False
        self.state_available = False
        self.obstacles_available = False
        self.reset_obstacles = True

        self.min_dist_obstacle_crossing = 0.9
        self.ang_on_path = math.pi / 5

        # Access rosparams
        #self.obstacles_top = rospy.get_param(rospy.get_name() + '/obstacles_topic')
        #self.car_pose_top = rospy.get_param(rospy.get_name() + "/car_pose_topic")
        #self.path_top = rospy.get_param(rospy.get_name() + "/path_topic")
        #self.replanner_path_top = rospy.get_param(rospy.get_name() + "/replanner_path_topic")

        # Publishers/Subscriber
        self.sub_obstacles = rospy.Subscriber('Obstacles', Obstacles, self.save_obstacles)
        #self.sub_car_pose = rospy.Subscriber(self.car_pose_top, PoseStamped, self.save_state)
        #self.sub_path = rospy.Subscriber(self.path_top, Path, self.save_path)
        #self.pub_path = rospy.Publisher(self.replanner_path_top, Path)
        #self.pub_marker = rospy.Publisher('/marker', PoseStamped)

    def save_path(self, path_msg):
        self.reference_path = path_msg
        self.path_available = True

    def save_state(self, state_msg):
        self.state_car = state_msg
        self.state_available = True

    def save_obstacles(self, obstacle_msg):
        self.obstacle_msg = obstacle_msg
        self.obstacles_available = True

    def transform2global(self, x, y):
        alpha = math.atan2(y, x)
        theta = math.pi + self.yaw_car
        rho = math.sqrt(x ** 2 + y ** 2)
        x_global = self.x_car + rho * math.cos(alpha + theta)
        y_global = self.y_car + rho * math.sin(alpha + theta)
        #return x_global, y_global
        return x, y

    def on_path(self, obstacle):
        obstacle_on_path = False
        for x, y in zip(self.previous_path.cx, self.previous_path.cy):
            if math.sqrt((x - obstacle.x) ** 2 + (y - obstacle.y) ** 2) < \
                    obstacle.r + self.safety_distance:
                obstacle_on_path = True
                break
        return obstacle_on_path

    def parse_obstacles(self, obstacle_msg):
        if self.reset_obstacles:
            self.circle_obstacles = []
        car_index = self.reference_path.get_closest_index_on_path(self.x_car, self.y_car)
        self.car_index = car_index
        for circle in obstacle_msg:#.circles:
            #x_obstacle_global, y_obstacle_global = self.transform2global(circle.center.x, circle.center.y)
            x_obstacle_global = circle.x
            y_obstacle_global = circle.y
            obstacle = path_utils.Obstacle(x_obstacle_global, y_obstacle_global, circle.radius)

            index_on_path = self.reference_path.get_closest_index_on_path(obstacle.x, obstacle.y)
            gradient_on_path = self.reference_path.compute_direction(index_on_path)

            # Compute n waypoints on the circle
            obstacle.compute_wp(gradient_on_path, self.safety_distance)
            obstacle.index_on_path = (index_on_path - car_index) % self.reference_path.get_length()
            if len(self.circle_obstacles) == 0:
                self.circle_obstacles.append(obstacle)
            else:
                for index, sorted_obstacle in enumerate(self.circle_obstacles):
                    if obstacle.index_on_path <= sorted_obstacle.index_on_path:
                        self.circle_obstacles.insert(index, obstacle)
                        break
                if obstacle.index_on_path > self.circle_obstacles[-1].index_on_path:
                    self.circle_obstacles.append(obstacle)

    def crossing(self, wp1, wp2):
        delta_x = wp1.obstacle.x - wp2.obstacle.x
        delta_y = wp1.obstacle.y - wp2.obstacle.y
        if delta_x != 0:
            m = delta_y / delta_x
            q = wp1.obstacle.y - m * wp1.obstacle.x
            if (wp1.y >= m * wp1.x + q) and (wp2.y >= m * wp2.x + q):
                return False
            if (wp1.y <= m * wp1.x + q) and (wp2.y <= m * wp2.x + q):
                return False
            return True
        else:
            if (wp1.x - wp1.obstacle.x) * (wp2.x - wp2.obstacle.x) >= 0:
                return False
        return True

    def check_feasible_path(self, current_wp, next_wp):
        if next_wp.obstacle is None:
            return True
        distance_obstacle = math.hypot(current_wp.obstacle.x - next_wp.obstacle.x,
                                       current_wp.obstacle.y - next_wp.obstacle.y)
        clean_distance = distance_obstacle - (current_wp.obstacle.r + next_wp.obstacle.r)
        if self.crossing(current_wp, next_wp) and clean_distance < self.min_dist_obstacle_crossing:
            return False
        else:
            return True

    def backward_recursion(self):
        fake_first_obstacle = path_utils.Obstacle(x=self.circle_obstacles[0].x,
                                                  y=self.circle_obstacles[0].y,
                                                  r=self.circle_obstacles[0].r)
        index_on_path = self.previous_path.get_closest_index_on_path(fake_first_obstacle.x, fake_first_obstacle.y)
        fake_first_obstacle.index_on_path = (index_on_path - self.car_index) % self.previous_path.get_length()
        fake_first_obstacle.waypoints = [path_utils.WayPoint(self.circle_obstacles[0].waypoints[0].x,
                                                             self.circle_obstacles[0].waypoints[0].y,
                                                             None)]
        self.circle_obstacles.append(fake_first_obstacle)
        for wp in self.circle_obstacles[-1].waypoints:
            wp.end = True
            wp.feasible = True
            wp.set_cost_to_go(0)

        for i in range(len(self.circle_obstacles)-2, -1, -1):
            current_obs = self.circle_obstacles[i]
            next_obs = self.circle_obstacles[i+1]
            next_wps = next_obs.waypoints
            log('CURRENT OBSTACLE: ' + str(current_obs.x) + ", " + str(current_obs.y))
            # TODO: If clear distance is enough: indexes on path / ds
            distance_on_path = ((next_obs.index_on_path - current_obs.index_on_path) % self.previous_path.get_length()) * self.previous_path.ds
            dist_last = (next_obs.r + next_obs.num_wp * self.safety_distance) / math.cos(self.ang_on_path)
            dist_first = (current_obs.r + current_obs.num_wp * self.safety_distance) / math.cos(self.ang_on_path)
            clean_distance = distance_on_path - (dist_last + dist_first)
            if clean_distance > self.min_dist_back_on_path:
                next_wps = []
                additional_wp = int(clean_distance / (self.previous_path.ds * 2))
                shift_index = int((clean_distance/additional_wp / self.previous_path.ds))
                bias_index = int(dist_last/self.previous_path.ds)
                old_wp_list = next_obs.waypoints
                for i in range(additional_wp):
                    current_wp_index = (next_obs.index_on_path - (shift_index * (i+1) + bias_index) + self.car_index) % self.previous_path.get_length()
                    new_wp = path_utils.WayPoint(self.previous_path.cx[current_wp_index], self.previous_path.cy[current_wp_index], None)
                    new_wp.feasible = True
                    self.find_optimal_next(new_wp, old_wp_list)
                    # new_wp.next_wp = old_wp
                    old_wp_list = [new_wp]
                next_wps = [new_wp]

            for wp0 in current_obs.waypoints:
                log('Current waypoint: ' + str(wp0.x) + ", " + str(wp0.y))
                if wp0.obstacle is not None:
                    log('   On obstacle: ' + str(wp0.obstacle.x) + ", " + str(wp0.obstacle.y))
                feasible_waypoints = []
                for wp1 in next_wps:
                    if wp1.feasible:
                        if self.check_feasible_path(wp0, wp1):
                            feasible_waypoints.append(wp1)
                if len(feasible_waypoints) == 0:
                    wp0.feasible = False
                else:
                    wp0.feasible = True
                    self.find_optimal_next(current_wp=wp0, next_feasible_wps=feasible_waypoints)

    def find_optimal_next(self, current_wp, next_feasible_wps):
        index_on_path = self.previous_path.get_closest_index_on_path(current_wp.x, current_wp.y)
        reward_now = math.hypot(current_wp.x - self.previous_path.cx[index_on_path],
                                current_wp.y - self.previous_path.cy[index_on_path])
        best_wp = next_feasible_wps[0]
        min_cost = 100

        for w in next_feasible_wps:
            log('       Possible future waypoint: ' + str(current_wp.x) + ", " + str(current_wp.y))
            if w.obstacle is not None:
                log('       On obstacle: ' + str(w.obstacle.x) + ", " + str(w.obstacle.y))
                log('       Future cost:' + str(w.get_cost_to_go()))
            if w.get_cost_to_go() < min_cost:
                min_cost = w.get_cost_to_go()
                best_wp = w
        log('           Best future cost: ' + str(min_cost))
        log('           With point: ' + str(best_wp.x) + ", " + str(best_wp.y))
        current_wp.set_cost_to_go(min_cost + reward_now)
        current_wp.next_wp = best_wp
        return best_wp


class FakeObstacle:
    def __init__(self, x, y, r):
        self.x = x
        self.y = y
        self.radius = r


if __name__ == "__main__":
    rospy.init_node('sample_planner')
    planner = DynamicPlanner(safety_distance=0.1)
    planner.x_car = 1
    planner.y_car = 0
    planner.yaw_car = math.pi/2
    circle_1 = FakeObstacle(0, 1.2, 0.1)
    circle_2 = FakeObstacle(1, 0, 0.1)
    circle_3 = FakeObstacle(-0.8, 0, 0.2)
    circle_4 = FakeObstacle(0, -1.2, 0.1)
    circle_5 = FakeObstacle(1, 0, 0.3)
    circle_6 = FakeObstacle(0.7, 0.7, 0.1)
    circle_7 = FakeObstacle(-0.7, -0.7, 0.1)
    obstacle_msg = [circle_1, circle_2]#, circle_3, circle_4, circle_5]
    start = timeit.timeit()
    planner.parse_obstacles(obstacle_msg)
    planner.backward_recursion()
    end = timeit.timeit()


    min_cost = 100
    start_wp = planner.circle_obstacles[0].waypoints[0]
    for wp in planner.circle_obstacles[0].waypoints:
        if wp.get_cost_to_go() < min_cost:
            min_cost = wp.get_cost_to_go()
            start_wp = wp    print(start_wp.x)
    print(start_wp.y)

    next_wp = start_wp
    to_be_splined_x = [start_wp.x]
    to_be_splined_y = [start_wp.y]
    end = False
    while not end:
        to_be_splined_x.append(next_wp.x)
        to_be_splined_y.append(next_wp.y)
        end = next_wp.end
        if not next_wp.end:
            next_wp = next_wp.next_wp
    spl = Spline2D(to_be_splined_x[1:], to_be_splined_y[1:])
    s = np.arange(0, spl.s[-1], 0.1)
    sx = []
    sy = []
    for i_s in s:
        ix, iy = spl.calc_position(i_s)
        sx.append(ix)
        sy.append(iy)
    #plt.plot(sx, sy)
    #plt.xlim([-2, 2])
    #plt.ylim([-2, 2])
    #plt.show()

    #plot_utils.planner_plot(planner)








